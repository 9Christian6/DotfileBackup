function addAlias(){echo "alias $1='$2'" >> ~/.zshrc; }

function search(){lsa|awk '{print $9}' | grep -i $1}

function showInstalled(){dpkg --list "*$1*"}

function makecd(){mkdir $1 && cd $1}

# function startSilent(){
#   echo "$(date '+%H:%M %d.%m.%Y') \"$1\":">>$HOME/ScriptOutputs/stdout
#   nohup "$@" 1>>$HOME/ScriptOutputs/stdout 2>>$HOME/ScriptOutputs/stderr
#   echo "\n">>$HOME/ScriptOutputs/stdout
# }

function startSilent(){
  local LOG_DIR="$HOME/ScriptOutputs"
  local TIMESTAMP="$(date '+%H:%M %d.%m.%Y')"

  # 1. Log the execution start to stdout file
  echo "$TIMESTAMP \"$1\":" >> "$LOG_DIR/stdout"

  # 2. Run the command
  # - Stdin is redirected from /dev/null to prevent nohup warnings.
  # - Stdout appends to your stdout log.
  # - Stderr is redirected to a process substitution >(...)
  nohup "$@" < /dev/null >> "$LOG_DIR/stdout" 2> >(
    # This block runs only for the error stream
    if read -r line; then
      # If we successfully read a line, it means there IS an error.
      # Print the timestamp header to stderr log
      echo "$TIMESTAMP \"$1\":" >> "$LOG_DIR/stderr"
      
      # Print the line we just captured
      echo "$line" >> "$LOG_DIR/stderr"
      
      # Use 'cat' to print the rest of the error stream (if any)
      cat >> "$LOG_DIR/stderr"
    fi
  )

  # 3. Append a spacer line to stdout
  echo "" >> "$LOG_DIR/stdout"
}

function open(){nohup xdg-open "$@" >/dev/null 2>&1&}

function unzip() {
  if [[ $# -eq 1 && "$1" == *.zip ]]; then
    local zipfile="$1"
      local dirname="${zipfile%.zip}"

      mkdir -p "$dirname"
      command unzip "$zipfile" -d "$dirname"
  else
    command unzip "$@"
      fi
}

function fcd() {
  local target
    target=$(find . -mindepth 1 \( -type d -o -type f \) | fzf) || return

    if [ -d "$target" ]; then
      cd "$target"
    else
      cd "$(dirname "$target")"
	fi
}
